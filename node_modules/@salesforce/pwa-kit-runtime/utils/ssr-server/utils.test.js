"use strict";

var utils = _interopRequireWildcard(require("./utils"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); } /*
                                                                                                                                                                                                                                                                                                                                                     * Copyright (c) 2022, Salesforce, Inc.
                                                                                                                                                                                                                                                                                                                                                     * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                     * SPDX-License-Identifier: BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                     */
describe.each([[true], [false]])('Utils remote/local tests (isRemote: %p)', isRemote => {
  let originalEnv;
  const bundleId = 'test-bundle-id-12345';
  beforeEach(() => {
    originalEnv = process.env;
    process.env = _extends({}, process.env);
    process.env.BUNDLE_ID = bundleId;
    if (isRemote) {
      process.env.AWS_LAMBDA_FUNCTION_NAME = 'remote-test-name';
    }
  });
  afterEach(() => {
    process.env = originalEnv;
    jest.restoreAllMocks();
  });
  test(`getBundleBaseUrl should return the correct URL`, () => {
    const expectedId = isRemote ? bundleId : 'development';
    const expected = `/mobify/bundle/${expectedId}/`;
    expect(utils.getBundleBaseUrl()).toBe(expected);
  });
  describe.each([[true], [false]])('Quiet/loud tests', quiet => {
    let originalQuiet;
    beforeEach(() => {
      originalQuiet = utils.isQuiet();
      utils.setQuiet(quiet);
    });
    afterEach(() => {
      utils.setQuiet(originalQuiet);
      jest.restoreAllMocks();
    });
    test(`localDevLog should log conditionally (quiet: ${quiet})`, () => {
      const log = jest.spyOn(console, 'log').mockImplementation(() => {});
      const msg = 'message';
      utils.localDevLog(msg);
      const expected = !isRemote && !quiet ? [[msg]] : [];
      expect(log.mock.calls).toEqual(expected);
    });
    test(`infoLog should log conditionally (quiet: ${quiet})`, () => {
      const log = jest.spyOn(console, 'log').mockImplementation(() => {});
      const msg = 'message';
      utils.infoLog(msg);
      const expected = !quiet ? [[msg]] : [];
      expect(log.mock.calls).toEqual(expected);
    });
  });
});
describe('catchAndLog', () => {
  test('error', () => {
    const error = jest.spyOn(console, 'error').mockImplementation(() => {});
    utils.catchAndLog();
    expect(error).toHaveBeenCalledWith('Uncaught exception: ', '(no error)');
  });
});