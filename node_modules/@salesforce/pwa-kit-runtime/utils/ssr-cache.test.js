"use strict";

var _ssrCache = require("./ssr-cache");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } /*
                                                                                                                                                                                                                                                                                                                                                                                                       * Copyright (c) 2021, salesforce.com, inc.
                                                                                                                                                                                                                                                                                                                                                                                                       * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                       * SPDX-License-Identifier: BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                                                                       * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                                                                       */
const localRemoteTestCases = [true, false];
localRemoteTestCases.forEach(useLocalCache => {
  describe(`${useLocalCache ? 'Local' : 'Remote'} noop PersistentCache`, () => {
    const testCache = new _ssrCache.PersistentCache({
      useLocalCache,
      bucket: 'TestBucket',
      s3Endpoint: 'http://localhost:4568',
      accessKeyId: 'S3RVER',
      secretAccessKey: 'S3RVER',
      sendMetric: () => {}
    });
    const key = 'key';
    const namespace = 'namespace';
    const buf = Buffer.alloc(8);
    for (let i = 0; i <= 8; i++) {
      buf[i] = i;
    }
    const expiration = Date.now() + 10000;
    test('get', /*#__PURE__*/_asyncToGenerator(function* () {
      const result = yield testCache.get({
        key,
        namespace
      });
      expect(result.data).toBeUndefined();
      expect(result.metadata).toBeUndefined();
      expect(result.found).toBe(false);
      expect(result.key).toEqual(key);
      expect(result.namespace).toEqual(namespace);
    }));
    test('put', /*#__PURE__*/_asyncToGenerator(function* () {
      yield testCache.put({
        key,
        namespace,
        data: buf,
        expiration
      });
      const result = yield testCache.get({
        key,
        namespace
      });
      expect(result.data).toBeUndefined();
      expect(result.metadata).toBeUndefined();
      expect(result.found).toBe(false);
      expect(result.key).toEqual(key);
      expect(result.namespace).toEqual(namespace);
    }));
    test('delete', /*#__PURE__*/_asyncToGenerator(function* () {
      yield expect(testCache.delete({
        key,
        namespace
      })).resolves.not.toThrow();
    }));
  });
});