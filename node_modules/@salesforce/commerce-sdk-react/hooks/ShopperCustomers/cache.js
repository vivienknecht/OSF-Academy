"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cacheUpdateMatrix = void 0;
var _queryKeyHelpers = require("./queryKeyHelpers");
var _utils = require("../utils");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /*
                                                                                                                                                                                                                                                                                                                                                                                           * Copyright (c) 2023, Salesforce, Inc.
                                                                                                                                                                                                                                                                                                                                                                                           * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                           * SPDX-License-Identifier: BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                                                           * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                                                           */
const noop = () => ({});

// ReactQuery type def for the updater function uses type `unknown` for the first param,
// this makes it hard to define the `createUpdateFunction` below, so we created this type.
// This is a slight variation of above, but we know the data is not null.
/**
 * Create an update handler for the cache matrix. This updater will implicitly clone and assert
 * that the data being passed to is is not undefined.
 *
 * @param update
 * @returns
 */
const createUpdateFunction = update => data => data ? update((0, _utils.clone)(data)) : undefined;
const cacheUpdateMatrix = {
  createCustomerAddress(customerId, {
    parameters
  }, response) {
    // getCustomerAddress uses `addressName` rather than `addressId`
    const newParams = _objectSpread(_objectSpread({}, parameters), {}, {
      addressName: response.addressId
    });
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerAddress.queryKey(newParams)
      }, {
        queryKey: _queryKeyHelpers.getCustomer.queryKey(newParams),
        updater: createUpdateFunction(customer => {
          // Push new address onto the end of addresses list.
          customer.addresses = [...(customer.addresses ?? []), response];
          return customer;
        })
      }]
    };
  },
  createCustomerPaymentInstrument(customerId, {
    parameters
  }, response) {
    const newParams = _objectSpread(_objectSpread({}, parameters), {}, {
      paymentInstrumentId: response.paymentInstrumentId
    });
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerPaymentInstrument.queryKey(newParams)
      }, {
        queryKey: _queryKeyHelpers.getCustomer.queryKey(newParams),
        updater: createUpdateFunction(customer => {
          customer.paymentInstruments = [...(customer.paymentInstruments ?? []), response];
          return customer;
        })
      }]
    };
  },
  createCustomerProductList(customerId, {
    parameters
  }, response) {
    // We always invalidate, because even without an ID we assume that something has changed
    const listId = response.id;
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          // Add new list to front of the lists.
          result.data.unshift(response);
          result.limit++;
          result.total++;
          return result;
        })
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(_objectSpread(_objectSpread({}, parameters), {}, {
          listId
        }))
      }]
    };
  },
  createCustomerProductListItem(customerId, {
    parameters
  }, response) {
    // We always invalidate, because even without an ID we assume that something has changed
    // QUESTION: Why would we get a response that doesn't have an ID?
    const itemId = response.id;
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductListItem.queryKey(_objectSpread(_objectSpread({}, parameters), {}, {
          itemId
        }))
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(parameters),
        updater: createUpdateFunction(list => {
          return _objectSpread(_objectSpread({}, list), {}, {
            customerProductListItems: [...((list === null || list === void 0 ? void 0 : list.customerProductListItems) || []), response]
          });
        })
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          // Find the list that we want to add the item to.
          const list = result.data.find(({
            id
          }) => id === parameters.listId);
          if (!list) {
            return;
          }
          list.customerProductListItems = [...(list.customerProductListItems ?? []), response];
          return result;
        })
      }]
    };
  },
  deleteCustomerPaymentInstrument(customerId, {
    parameters
  }) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomer.queryKey(parameters),
        updater: createUpdateFunction(customer => {
          var _customer$paymentInst, _customer$paymentInst2;
          const paymentInstrumentIndex = (_customer$paymentInst = customer.paymentInstruments) === null || _customer$paymentInst === void 0 ? void 0 : _customer$paymentInst.findIndex(({
            paymentInstrumentId
          }) => paymentInstrumentId === parameters.paymentInstrumentId);

          // Return undefined (no changes) if no payment instrument was found.
          if (paymentInstrumentIndex === undefined || paymentInstrumentIndex < 0) {
            return;
          }

          // Remove the found payment instrument.
          (_customer$paymentInst2 = customer.paymentInstruments) === null || _customer$paymentInst2 === void 0 ? void 0 : _customer$paymentInst2.splice(paymentInstrumentIndex, 1);
          return customer;
        })
      }],
      remove: [{
        queryKey: _queryKeyHelpers.getCustomerPaymentInstrument.queryKey(parameters)
      }]
    };
  },
  deleteCustomerProductList(customerId, {
    parameters
  }) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          const listIndex = result.data.findIndex(({
            id
          }) => id === parameters.listId);

          // Return undefined if no list is found
          if (listIndex < 0) {
            return;
          }

          // Remove the list from the result object
          result.data.splice(listIndex, 1);
          result.limit--;
          result.total--;
          return result;
        })
      }],
      remove: [{
        queryKey: _queryKeyHelpers.getCustomerProductList.path(parameters)
      }]
    };
  },
  deleteCustomerProductListItem(customerId, {
    parameters
  }) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(parameters),
        updater: createUpdateFunction(list => {
          var _list$customerProduct, _list$customerProduct2;
          const itemIndex = (_list$customerProduct = list.customerProductListItems) === null || _list$customerProduct === void 0 ? void 0 : _list$customerProduct.findIndex(({
            id
          }) => id === parameters.itemId);

          // Return undefined if there is no item found.
          if (itemIndex === undefined || itemIndex < 0) {
            return;
          }

          // Remove the list item
          (_list$customerProduct2 = list.customerProductListItems) === null || _list$customerProduct2 === void 0 ? void 0 : _list$customerProduct2.splice(itemIndex, 1);
          return list;
        })
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          var _list$customerProduct3, _list$customerProduct4;
          const list = result.data.find(({
            id
          }) => id === parameters.listId);
          const itemIndex = list === null || list === void 0 ? void 0 : (_list$customerProduct3 = list.customerProductListItems) === null || _list$customerProduct3 === void 0 ? void 0 : _list$customerProduct3.findIndex(({
            id
          }) => id === parameters.itemId);

          // Return undefined if no item was found in the provided list.
          if (itemIndex === undefined || itemIndex < 0) {
            return;
          }

          // Remove the item from the list.
          list === null || list === void 0 ? void 0 : (_list$customerProduct4 = list.customerProductListItems) === null || _list$customerProduct4 === void 0 ? void 0 : _list$customerProduct4.splice(itemIndex, 1);
          return result;
        })
      }],
      remove: [{
        queryKey: _queryKeyHelpers.getCustomerProductListItem.queryKey(parameters)
      }]
    };
  },
  getResetPasswordToken: noop,
  // TODO: Should this update the `getCustomer` cache?
  registerCustomer: noop,
  // TODO: Implement when the endpoint exits closed beta.
  // registerExternalProfile: TODO('registerExternalProfile'),
  removeCustomerAddress(customerId, {
    parameters
  }) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomer.queryKey(parameters),
        updater: createUpdateFunction(customer => {
          var _customer$addresses, _customer$addresses2;
          const addressIndex = (_customer$addresses = customer.addresses) === null || _customer$addresses === void 0 ? void 0 : _customer$addresses.findIndex(({
            addressId
          }) => addressId === parameters.addressName);

          // Return undefined if the address is not found...
          if (addressIndex === undefined || addressIndex < 0) {
            return;
          }

          // Remove the found address.
          (_customer$addresses2 = customer.addresses) === null || _customer$addresses2 === void 0 ? void 0 : _customer$addresses2.splice(addressIndex, 1);
          return customer;
        })
      }],
      remove: [{
        queryKey: _queryKeyHelpers.getCustomerAddress.queryKey(parameters)
      }]
    };
  },
  resetPassword: noop,
  updateCustomer(customerId, {
    parameters
  }) {
    // When we update a customer, we don't know what data has changed, so we must invalidate all
    // derivative endpoints. They conveniently all start with the same path as `getCustomer`,
    // but we do NOT want to invalidate `getCustomer` itself, we want to _update_ it. (Ideally,
    // we could invalidate *then* update, but React Query can't handle that.) To do so, we
    // examine the path of each cached query. If it starts with the `getCustomer` path, we
    // invalidate, UNLESS the first item afer the path is an object, because that means that it
    // is the `getCustomer` query itself.
    const path = _queryKeyHelpers.getCustomer.path(parameters);
    const isNotGetCustomer = ({
      queryKey
    }) => typeof queryKey[path.length] !== 'object';
    const predicate = (0, _utils.and)((0, _utils.pathStartsWith)(path), isNotGetCustomer);
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomer.queryKey(parameters)
      }],
      invalidate: [{
        predicate
      }]
    };
  },
  updateCustomerAddress(customerId, {
    parameters
  }, response) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerAddress.queryKey(parameters)
      }, {
        queryKey: _queryKeyHelpers.getCustomer.queryKey(parameters),
        updater: createUpdateFunction(customer => {
          if (!customer.addresses) return;
          const addressIndex = customer.addresses.findIndex(({
            addressId
          }) => addressId === response.addressId);

          // Return undefined if no address is found...
          if (addressIndex === undefined || addressIndex < 0) {
            return;
          }

          // Update the found address.
          customer.addresses[addressIndex] = response;
          return customer;
        })
      }]
    };
  },
  updateCustomerPassword: noop,
  updateCustomerProductList(customerId, {
    parameters
  }, response) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(parameters)
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          const listIndex = result.data.findIndex(({
            id
          }) => id === response.id);

          // Return undefined if we didn't find the product list we were looking for.
          if (listIndex < 0) {
            return;
          }

          // Update the product list.
          result.data[listIndex] = response;
          return result;
        })
      }]
    };
  },
  updateCustomerProductListItem(customerId, {
    parameters
  }, response) {
    return {
      update: [{
        queryKey: _queryKeyHelpers.getCustomerProductListItem.queryKey(parameters)
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductList.queryKey(parameters),
        updater: createUpdateFunction(list => {
          var _list$customerProduct5;
          if (!list.customerProductListItems) return;
          // Find the index of the item we want to update.
          const itemIndex = (_list$customerProduct5 = list.customerProductListItems) === null || _list$customerProduct5 === void 0 ? void 0 : _list$customerProduct5.findIndex(({
            id
          }) => id === parameters.itemId);

          // Return undefined when item isn't found.
          if (itemIndex === undefined || itemIndex < 0) {
            return;
          }
          list.customerProductListItems[itemIndex] = response;
          return list;
        })
      }, {
        queryKey: _queryKeyHelpers.getCustomerProductLists.queryKey(parameters),
        updater: createUpdateFunction(result => {
          // Find the list with the current list id.
          const listIndex = result.data.findIndex(({
            id
          }) => id === parameters.listId);
          // Find the index of the item in the list.
          const items = result.data[listIndex].customerProductListItems;
          if (!items) return;
          const itemIndex = items.findIndex(({
            id
          }) => id === parameters.itemId);

          // Return undefined if item isn't found...
          if (itemIndex === undefined || itemIndex < 0) return;

          // Update the item in the found list.
          // NOTE: We know that there is an item to update given the item index is > -1
          items[itemIndex] = response;
          return result;
        })
      }]
    };
  }
};
exports.cacheUpdateMatrix = cacheUpdateMatrix;